/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/magic-wand-tool";
exports.ids = ["vendor-chunks/magic-wand-tool"];
exports.modules = {

/***/ "(ssr)/./node_modules/magic-wand-tool/dist/magic-wand.js":
/*!*********************************************************!*\
  !*** ./node_modules/magic-wand-tool/dist/magic-wand.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/*\n Magic wand tool (fuzzy selection) by color\n\n @package magic-wand-tool\n @author Ryasnoy Paul <ryasnoypaul@gmail.com>\n @version 1.1.7\n @license MIT\n @copyright (c) 2014-2020, Ryasnoy Paul <ryasnoypaul@gmail.com>\n\n*/\n\nvar MagicWand = (function () {\r\n    var lib = {};\r\n\r\n    /** Create a binary mask on the image by color threshold\r\n      * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\r\n      * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\r\n      * @param {int} x of start pixel\r\n      * @param {int} y of start pixel\r\n      * @param {int} color threshold\r\n      * @param {Uint8Array} mask of visited points (optional) \r\n      * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.floodFill = function(image, px, py, colorThreshold, mask, includeBorders) {\r\n        return includeBorders\r\n            ? floodFillWithBorders(image, px, py, colorThreshold, mask)\r\n            : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\r\n    };\r\n\r\n    function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n\r\n                    xl--;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n\r\n                    xr++;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    }\r\n    function floodFillWithBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n                    xl--;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n                    xr++;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    }\r\n    /** Apply the gauss-blur filter to binary mask\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlur = function(mask, radius) {\r\n\r\n        var i, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n            s2 = radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            var dsq = (radius - i) * (radius - i);\r\n            var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(w * h), // result mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all source points for blur\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                val = 0;\r\n                k = y * w + x; // index of the point\r\n                start = radius - x > 0 ? radius - x : 0;\r\n                end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                k1 = k - radius;\r\n                // walk through x-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i] * wg[i];\r\n                }\r\n                start = radius - y > 0 ? radius - y : 0;\r\n                end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                k1 = k - radius * w;\r\n                // walk through y-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i * w] * wg[i];\r\n                }\r\n                result[k] = val > 0.5 ? 1 : 0;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border index array of boundary points of the mask with radius-neighbors\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\r\n      */\r\n    function createBorderForBlur(mask, radius, visited) {\r\n\r\n        var x, i, j, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            visitedData = new Uint8Array(data),\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = w * h,\r\n            temp = new Uint8Array(len), // auxiliary array to check uniqueness\r\n            border = [], // only border points\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        if (visited && visited.length > 0) {\r\n            // copy visited points (only \"black\")\r\n            for (k = 0; k < len; k++) {\r\n                if (visited[k] === 1) visitedData[k] = 1;\r\n            }\r\n        }\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\r\n                    visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\r\n                    visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\r\n                    //if (visitedData[k + 1] + visitedData[k - 1] + \r\n                    //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\r\n                    //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    border.push(y * w);\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    border.push(y * w + maxX);\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    border.push(x);\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    border.push(maxY * w + x);\r\n\r\n        var result = [], // border points with radius-neighbors\r\n            start, end,\r\n            endX = radius + w,\r\n            endY = radius + h,\r\n            n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n\r\n        len = border.length;\r\n        // walk through radius-neighbors of border points and add them to the result array\r\n        for (j = 0; j < len; j++) {\r\n            k = border[j]; // index of the border point\r\n            temp[k] = 1; // mark border point\r\n            result.push(k); // save the border point\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i * w;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\r\n\r\n        var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\r\n            ww, dsq, i, j, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\r\n            s2 = 2 * radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = border.length;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            dsq = (radius - i) * (radius - i);\r\n            ww = Math.exp(-dsq / s2) / Math.PI;\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(data), // copy the source mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all border points for blur\r\n        for (i = 0; i < len; i++) {\r\n            k = border[i]; // index of the border point\r\n            val = 0;\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n                continue;\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j * w] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n            } else {\r\n                result[k] = 0;\r\n            }\r\n        }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border mask (only boundary points)\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    lib.createBorderMask = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 1, // bounds size\r\n            rh = maxY - minY + 1,\r\n            result = new Uint8Array(rw * rh), // reduced mask (bounds size)\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    result[(y - minY) * rw + (x - minX)] = 1;\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    result[(y - minY) * rw] = 1;\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    result[(y - minY) * rw + (maxX - minX)] = 1;\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    result[x - minX] = 1;\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    result[(maxY - minY) * rw + (x - minX)] = 1;\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX, y: minY }\r\n        };\r\n    };\r\n    \r\n    /** Create a border index array of boundary points of the mask\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\r\n      * @return {Array} border index array boundary points of the mask\r\n      */\r\n    lib.getBorderIndices = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            border = [], // only border points\r\n            x1 = w - 1,\r\n            y1 = h - 1;\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = 1; y < y1; y++)\r\n            for (x = 1; x < x1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w] === 1)\r\n                border.push(y * w);\r\n\r\n        for (x = 0; x < w; x++)\r\n            if (data[x] === 1)\r\n                border.push(x);\r\n\r\n        k = w - 1;\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w + k] === 1)\r\n                border.push(y * w + k);\r\n\r\n        k = (h - 1) * w;\r\n        for (x = 0; x < w; x++)\r\n            if (data[k + x] === 1)\r\n                border.push(k + x);\r\n\r\n        return border;\r\n    };\r\n    \r\n    /** Create a compressed mask with a \"white\" border (1px border with zero values) for the contour tracing\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    function prepareMask(mask) {\r\n        var x, y,\r\n            w = mask.width,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 3, // bounds size +1 px on each side (a \"white\" border)\r\n            rh = maxY - minY + 3,\r\n            result = new Uint8Array(rw * rh); // reduced mask (bounds size)\r\n\r\n        // walk through inner values and copy only \"black\" points to the result mask\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                if (data[y * w + x] === 1)\r\n                    result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX - 1, y: minY - 1 }\r\n        };\r\n    }        \r\n    /** Create a contour array for the binary mask\r\n      * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label\r\n      */\r\n    lib.traceContours = function(mask) {\r\n        var m = prepareMask(mask),\r\n            contours = [],\r\n            label = 0,\r\n            w = m.width,\r\n            w2 = w * 2,\r\n            h = m.height,\r\n            src = m.data,\r\n            dx = m.offset.x,\r\n            dy = m.offset.y,\r\n            dest = new Uint8Array(src), // label matrix\r\n            i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\r\n\r\n        // all [dx,dy] pairs (array index is the direction)\r\n        // 5 6 7\r\n        // 4 X 0\r\n        // 3 2 1\r\n        var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\r\n\r\n        for (y = 1; y < h - 1; y++)\r\n            for (x = 1; x < w - 1; x++) {\r\n                k = y * w + x;\r\n                if (src[k] === 1) {\r\n                    for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\r\n                        if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\r\n                            inner = i === w; // is inner contour tracing ?\r\n                            label++; // label for the next contour\r\n\r\n                            c = [];\r\n                            dir = inner ? 2 : 6; // start direction\r\n                            current = previous = first = { x: x, y: y };\r\n                            second = null;\r\n                            while (true) {\r\n                                dest[current.y * w + current.x] = label; // mark label for the current point \r\n                                // bypass all the neighbors around the current point in a clockwise\r\n                                for (j = 0; j < 8; j++) {\r\n                                    dir = (dir + 1) % 8;\r\n\r\n                                    // get the next point by new direction\r\n                                    d = directions[dir]; // index as direction\r\n                                    next = { x: current.x + d[0], y: current.y + d[1] };\r\n\r\n                                    k1 = next.y * w + next.x;\r\n                                    if (src[k1] === 1) // black boundary pixel\r\n                                    {\r\n                                        dest[k1] = label; // mark a label\r\n                                        break;\r\n                                    }\r\n                                    dest[k1] = -1; // mark a white boundary pixel\r\n                                    next = null;\r\n                                }\r\n                                if (next === null) break; // no neighbours (one-point contour)\r\n                                current = next;\r\n                                if (second) {\r\n                                    if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\r\n                                        break; // creating the contour completed when returned to original position\r\n                                    }\r\n                                } else {\r\n                                    second = next;\r\n                                }\r\n                                c.push({ x: previous.x + dx, y: previous.y + dy });\r\n                                previous = current;\r\n                                dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\r\n                            }\r\n\r\n                            if (next != null) {\r\n                                c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\r\n                                contours.push({ inner: inner, label: label, points: c }); // add contour to the list\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        return contours;\r\n    };\r\n    \r\n    /** Simplify contours\r\n      * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html \r\n      * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\r\n      * @param {Array} contours: {Array} points, {bool} inner, {int} label\r\n      * @param {float} simplify tolerant\r\n      * @param {int} simplify count: min number of points when the contour is simplified\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\r\n      */\r\n    lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\r\n        var lenContours = contours.length,\r\n            result = [],\r\n            i, j, k, c, points, len, resPoints, lst, stack, ids,\r\n            maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\r\n\r\n        // walk through all contours \r\n        for (j = 0; j < lenContours; j++) {\r\n            c = contours[j];\r\n            points = c.points;\r\n            len = c.points.length;\r\n\r\n            if (len < simplifyCount) { // contour isn't simplified\r\n                resPoints = [];\r\n                for (k = 0; k < len; k++) {\r\n                    resPoints.push({ x: points[k].x, y: points[k].y });\r\n                }\r\n                result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\r\n                continue;\r\n            }\r\n\r\n            lst = [0, len - 1]; // always add first and last points\r\n            stack = [{ first: 0, last: len - 1 }]; // first processed edge\r\n\r\n            do {\r\n                ids = stack.shift();\r\n                if (ids.last <= ids.first + 1) // no intermediate points\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                maxd = -1.0; // max distance from point to current edge\r\n                maxi = ids.first; // index of maximally distant point\r\n\r\n                for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\r\n                {\r\n                    // calc the distance from current point to edge\r\n                    pi = points[i];\r\n                    pf = points[ids.first];\r\n                    pl = points[ids.last];\r\n                    dx = pi.x - pf.x;\r\n                    dy = pi.y - pf.y;\r\n                    r1 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pi.x - pl.x;\r\n                    dy = pi.y - pl.y;\r\n                    r2 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pf.x - pl.x;\r\n                    dy = pf.y - pl.y;\r\n                    r12 = Math.sqrt(dx * dx + dy * dy);\r\n                    if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\r\n                    else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\r\n                    else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\r\n\r\n                    if (dist > maxd) {\r\n                        maxi = i; // save the index of maximally distant point\r\n                        maxd = dist;\r\n                    }\r\n                }\r\n\r\n                if (maxd > simplifyTolerant) // if the max \"deviation\" is larger than allowed then...\r\n                {\r\n                    lst.push(maxi); // add index to the simplified list\r\n                    stack.push({ first: ids.first, last: maxi }); // add the left part for processing\r\n                    stack.push({ first: maxi, last: ids.last }); // add the right part for processing\r\n                }\r\n\r\n            } while (stack.length > 0);\r\n\r\n            resPoints = [];\r\n            len = lst.length;\r\n            lst.sort(function(a, b) { return a - b; }); // restore index order\r\n            for (k = 0; k < len; k++) {\r\n                resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\r\n            }\r\n            result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    return lib;\r\n})();\r\n\r\nif ( true && module !== null) module.exports = MagicWand;\r\nif (typeof window !== \"undefined\" && window !== null) window.MagicWand = MagicWand;\n//# sourceMappingURL=magic-wand.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFnaWMtd2FuZC10b29sL2Rpc3QvbWFnaWMtd2FuZC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxRQUFRLFlBQVksT0FBTyxLQUFLLFFBQVEsS0FBSyxTQUFTLEtBQUs7QUFDbkYsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLFNBQVM7QUFDekIsaUJBQWlCLFFBQVEsT0FBTyxZQUFZLE9BQU8sS0FBSyxRQUFRLEtBQUssU0FBUyxRQUFRO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRFQUE0RTtBQUM1RTtBQUNBLHVCQUF1Qiw0Q0FBNEMsR0FBRztBQUN0RTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxtREFBbUQ7QUFDbkQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNy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Olsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYWdpYy13YW5kLXRvb2wvZGlzdC9tYWdpYy13YW5kLmpzP2U1MGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBNYWdpYyB3YW5kIHRvb2wgKGZ1enp5IHNlbGVjdGlvbikgYnkgY29sb3JcblxuIEBwYWNrYWdlIG1hZ2ljLXdhbmQtdG9vbFxuIEBhdXRob3IgUnlhc25veSBQYXVsIDxyeWFzbm95cGF1bEBnbWFpbC5jb20+XG4gQHZlcnNpb24gMS4xLjdcbiBAbGljZW5zZSBNSVRcbiBAY29weXJpZ2h0IChjKSAyMDE0LTIwMjAsIFJ5YXNub3kgUGF1bCA8cnlhc25veXBhdWxAZ21haWwuY29tPlxuXG4qL1xuXG52YXIgTWFnaWNXYW5kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBsaWIgPSB7fTtcclxuXHJcbiAgICAvKiogQ3JlYXRlIGEgYmluYXJ5IG1hc2sgb24gdGhlIGltYWdlIGJ5IGNvbG9yIHRocmVzaG9sZFxyXG4gICAgICAqIEFsZ29yaXRobTogU2NhbmxpbmUgZmxvb2QgZmlsbCAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG9vZF9maWxsKVxyXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZToge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHQsIHtpbnR9IGJ5dGVzXHJcbiAgICAgICogQHBhcmFtIHtpbnR9IHggb2Ygc3RhcnQgcGl4ZWxcclxuICAgICAgKiBAcGFyYW0ge2ludH0geSBvZiBzdGFydCBwaXhlbFxyXG4gICAgICAqIEBwYXJhbSB7aW50fSBjb2xvciB0aHJlc2hvbGRcclxuICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1hc2sgb2YgdmlzaXRlZCBwb2ludHMgKG9wdGlvbmFsKSBcclxuICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlQm9yZGVycz1mYWxzZV0gaW5kaWNhdGUgd2hldGhlciB0byBpbmNsdWRlIGJvcmRlcnMgcGl4ZWxzXHJcbiAgICAgICogQHJldHVybiB7T2JqZWN0fSBtYXNrOiB7VWludDhBcnJheX0gZGF0YSwge2ludH0gd2lkdGgsIHtpbnR9IGhlaWdodCwge09iamVjdH0gYm91bmRzXHJcbiAgICAgICovXHJcbiAgICBsaWIuZmxvb2RGaWxsID0gZnVuY3Rpb24oaW1hZ2UsIHB4LCBweSwgY29sb3JUaHJlc2hvbGQsIG1hc2ssIGluY2x1ZGVCb3JkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVCb3JkZXJzXHJcbiAgICAgICAgICAgID8gZmxvb2RGaWxsV2l0aEJvcmRlcnMoaW1hZ2UsIHB4LCBweSwgY29sb3JUaHJlc2hvbGQsIG1hc2spXHJcbiAgICAgICAgICAgIDogZmxvb2RGaWxsV2l0aG91dEJvcmRlcnMoaW1hZ2UsIHB4LCBweSwgY29sb3JUaHJlc2hvbGQsIG1hc2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmbG9vZEZpbGxXaXRob3V0Qm9yZGVycyhpbWFnZSwgcHgsIHB5LCBjb2xvclRocmVzaG9sZCwgbWFzaykge1xyXG5cclxuICAgICAgICB2YXIgYywgeCwgbmV3WSwgZWwsIHhyLCB4bCwgZHksIGR5bCwgZHlyLCBjaGVja1ksXHJcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZS5kYXRhLFxyXG4gICAgICAgICAgICB3ID0gaW1hZ2Uud2lkdGgsXHJcbiAgICAgICAgICAgIGggPSBpbWFnZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIGJ5dGVzID0gaW1hZ2UuYnl0ZXMsIC8vIG51bWJlciBvZiBieXRlcyBpbiB0aGUgY29sb3JcclxuICAgICAgICAgICAgbWF4WCA9IC0xLCBtaW5YID0gdyArIDEsIG1heFkgPSAtMSwgbWluWSA9IGggKyAxLFxyXG4gICAgICAgICAgICBpID0gcHkgKiB3ICsgcHgsIC8vIHN0YXJ0IHBvaW50IGluZGV4IGluIHRoZSBtYXNrIGRhdGFcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodyAqIGgpLCAvLyByZXN1bHQgbWFza1xyXG4gICAgICAgICAgICB2aXNpdGVkID0gbmV3IFVpbnQ4QXJyYXkobWFzayA/IG1hc2sgOiB3ICogaCk7IC8vIG1hc2sgb2YgdmlzaXRlZCBwb2ludHNcclxuXHJcbiAgICAgICAgaWYgKHZpc2l0ZWRbaV0gPT09IDEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBpID0gaSAqIGJ5dGVzOyAvLyBzdGFydCBwb2ludCBpbmRleCBpbiB0aGUgaW1hZ2UgZGF0YVxyXG4gICAgICAgIHZhciBzYW1wbGVDb2xvciA9IFtkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0sIGRhdGFbaSArIDNdXTsgLy8gc3RhcnQgcG9pbnQgY29sb3IgKHNhbXBsZSlcclxuXHJcbiAgICAgICAgdmFyIHN0YWNrID0gW3sgeTogcHksIGxlZnQ6IHB4IC0gMSwgcmlnaHQ6IHB4ICsgMSwgZGlyOiAxIH1dOyAvLyBmaXJzdCBzY2FubmluZyBsaW5lXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBlbCA9IHN0YWNrLnNoaWZ0KCk7IC8vIGdldCBsaW5lIGZvciBzY2FubmluZ1xyXG5cclxuICAgICAgICAgICAgY2hlY2tZID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoeCA9IGVsLmxlZnQgKyAxOyB4IDwgZWwucmlnaHQ7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgZHkgPSBlbC55ICogdztcclxuICAgICAgICAgICAgICAgIGkgPSAoZHkgKyB4KSAqIGJ5dGVzOyAvLyBwb2ludCBpbmRleCBpbiB0aGUgaW1hZ2UgZGF0YVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2R5ICsgeF0gPT09IDEpIGNvbnRpbnVlOyAvLyBjaGVjayB3aGV0aGVyIHRoZSBwb2ludCBoYXMgYmVlbiB2aXNpdGVkXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpXSAtIHNhbXBsZUNvbG9yWzBdOyAvLyBjaGVjayBieSByZWRcclxuICAgICAgICAgICAgICAgIGlmIChjID4gY29sb3JUaHJlc2hvbGQgfHwgYyA8IC1jb2xvclRocmVzaG9sZCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgIGlmIChjID4gY29sb3JUaHJlc2hvbGQgfHwgYyA8IC1jb2xvclRocmVzaG9sZCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMl0gLSBzYW1wbGVDb2xvclsyXTsgLy8gY2hlY2sgYnkgYmx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjaGVja1kgPSB0cnVlOyAvLyBpZiB0aGUgY29sb3Igb2YgdGhlIG5ldyBwb2ludCh4LHkpIGlzIHNpbWlsYXIgdG8gdGhlIHNhbXBsZSBjb2xvciBuZWVkIHRvIGNoZWNrIG1pbm1heCBmb3IgWSBcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHRbZHkgKyB4XSA9IDE7IC8vIG1hcmsgYSBuZXcgcG9pbnQgaW4gbWFza1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtkeSArIHhdID0gMTsgLy8gbWFyayBhIG5ldyBwb2ludCBhcyB2aXNpdGVkXHJcblxyXG4gICAgICAgICAgICAgICAgeGwgPSB4IC0gMTtcclxuICAgICAgICAgICAgICAgIC8vIHdhbGsgdG8gbGVmdCBzaWRlIHN0YXJ0aW5nIHdpdGggdGhlIGxlZnQgbmVpZ2hib3JcclxuICAgICAgICAgICAgICAgIHdoaWxlICh4bCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHlsID0gZHkgKyB4bDtcclxuICAgICAgICAgICAgICAgICAgICBpID0gZHlsICogYnl0ZXM7IC8vIHBvaW50IGluZGV4IGluIHRoZSBpbWFnZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbZHlsXSA9PT0gMSkgYnJlYWs7IC8vIGNoZWNrIHdoZXRoZXIgdGhlIHBvaW50IGhhcyBiZWVuIHZpc2l0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGRhdGFbaV0gLSBzYW1wbGVDb2xvclswXTsgLy8gY2hlY2sgYnkgcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGNvbG9yVGhyZXNob2xkIHx8IGMgPCAtY29sb3JUaHJlc2hvbGQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBkYXRhW2kgKyAyXSAtIHNhbXBsZUNvbG9yWzJdOyAvLyBjaGVjayBieSBibHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2R5bF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbZHlsXSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhsLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB4ciA9IHggKyAxO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0byByaWdodCBzaWRlIHN0YXJ0aW5nIHdpdGggdGhlIHJpZ2h0IG5laWdoYm9yXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoeHIgPCB3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHlyID0gZHkgKyB4cjtcclxuICAgICAgICAgICAgICAgICAgICBpID0gZHlyICogYnl0ZXM7IC8vIGluZGV4IHBvaW50IGluIHRoZSBpbWFnZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbZHlyXSA9PT0gMSkgYnJlYWs7IC8vIGNoZWNrIHdoZXRoZXIgdGhlIHBvaW50IGhhcyBiZWVuIHZpc2l0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGRhdGFbaV0gLSBzYW1wbGVDb2xvclswXTsgLy8gY2hlY2sgYnkgcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGNvbG9yVGhyZXNob2xkIHx8IGMgPCAtY29sb3JUaHJlc2hvbGQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBkYXRhW2kgKyAyXSAtIHNhbXBsZUNvbG9yWzJdOyAvLyBjaGVjayBieSBibHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2R5cl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbZHlyXSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhyKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgbWlubWF4IGZvciBYXHJcbiAgICAgICAgICAgICAgICBpZiAoeGwgPCBtaW5YKSBtaW5YID0geGwgKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhyID4gbWF4WCkgbWF4WCA9IHhyIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXdZID0gZWwueSAtIGVsLmRpcjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdZID49IDAgJiYgbmV3WSA8IGgpIHsgLy8gYWRkIHR3byBzY2FubmluZyBsaW5lcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uICh5IC0gZGlyKSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGwgPCBlbC5sZWZ0KSBzdGFjay5wdXNoKHsgeTogbmV3WSwgbGVmdDogeGwsIHJpZ2h0OiBlbC5sZWZ0LCBkaXI6IC1lbC5kaXIgfSk7IC8vIGZyb20gXCJuZXcgbGVmdFwiIHRvIFwiY3VycmVudCBsZWZ0XCJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucmlnaHQgPCB4cikgc3RhY2sucHVzaCh7IHk6IG5ld1ksIGxlZnQ6IGVsLnJpZ2h0LCByaWdodDogeHIsIGRpcjogLWVsLmRpciB9KTsgLy8gZnJvbSBcImN1cnJlbnQgcmlnaHRcIiB0byBcIm5ldyByaWdodFwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gZWwueSArIGVsLmRpcjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdZID49IDAgJiYgbmV3WSA8IGgpIHsgLy8gYWRkIHRoZSBzY2FubmluZyBsaW5lIGluIHRoZSBkaXJlY3Rpb24gKHkgKyBkaXIpIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bCA8IHhyKSBzdGFjay5wdXNoKHsgeTogbmV3WSwgbGVmdDogeGwsIHJpZ2h0OiB4ciwgZGlyOiBlbC5kaXIgfSk7IC8vIGZyb20gXCJuZXcgbGVmdFwiIHRvIFwibmV3IHJpZ2h0XCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayBtaW5tYXggZm9yIFkgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIGlmIChjaGVja1kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC55IDwgbWluWSkgbWluWSA9IGVsLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwueSA+IG1heFkpIG1heFkgPSBlbC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdCxcclxuICAgICAgICAgICAgd2lkdGg6IGltYWdlLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodCxcclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICBtaW5YOiBtaW5YLFxyXG4gICAgICAgICAgICAgICAgbWluWTogbWluWSxcclxuICAgICAgICAgICAgICAgIG1heFg6IG1heFgsXHJcbiAgICAgICAgICAgICAgICBtYXhZOiBtYXhZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmxvb2RGaWxsV2l0aEJvcmRlcnMoaW1hZ2UsIHB4LCBweSwgY29sb3JUaHJlc2hvbGQsIG1hc2spIHtcclxuXHJcbiAgICAgICAgdmFyIGMsIHgsIG5ld1ksIGVsLCB4ciwgeGwsIGR5LCBkeWwsIGR5ciwgY2hlY2tZLFxyXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2UuZGF0YSxcclxuICAgICAgICAgICAgdyA9IGltYWdlLndpZHRoLFxyXG4gICAgICAgICAgICBoID0gaW1hZ2UuaGVpZ2h0LFxyXG4gICAgICAgICAgICBieXRlcyA9IGltYWdlLmJ5dGVzLCAvLyBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGNvbG9yXHJcbiAgICAgICAgICAgIG1heFggPSAtMSwgbWluWCA9IHcgKyAxLCBtYXhZID0gLTEsIG1pblkgPSBoICsgMSxcclxuICAgICAgICAgICAgaSA9IHB5ICogdyArIHB4LCAvLyBzdGFydCBwb2ludCBpbmRleCBpbiB0aGUgbWFzayBkYXRhXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHcgKiBoKSwgLy8gcmVzdWx0IG1hc2tcclxuICAgICAgICAgICAgdmlzaXRlZCA9IG5ldyBVaW50OEFycmF5KG1hc2sgPyBtYXNrIDogdyAqIGgpOyAvLyBtYXNrIG9mIHZpc2l0ZWQgcG9pbnRzXHJcblxyXG4gICAgICAgIGlmICh2aXNpdGVkW2ldID09PSAxKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgaSA9IGkgKiBieXRlczsgLy8gc3RhcnQgcG9pbnQgaW5kZXggaW4gdGhlIGltYWdlIGRhdGFcclxuICAgICAgICB2YXIgc2FtcGxlQ29sb3IgPSBbZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdLCBkYXRhW2kgKyAzXV07IC8vIHN0YXJ0IHBvaW50IGNvbG9yIChzYW1wbGUpXHJcblxyXG4gICAgICAgIHZhciBzdGFjayA9IFt7IHk6IHB5LCBsZWZ0OiBweCAtIDEsIHJpZ2h0OiBweCArIDEsIGRpcjogMSB9XTsgLy8gZmlyc3Qgc2Nhbm5pbmcgbGluZVxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZWwgPSBzdGFjay5zaGlmdCgpOyAvLyBnZXQgbGluZSBmb3Igc2Nhbm5pbmdcclxuXHJcbiAgICAgICAgICAgIGNoZWNrWSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHggPSBlbC5sZWZ0ICsgMTsgeCA8IGVsLnJpZ2h0OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGR5ID0gZWwueSAqIHc7XHJcbiAgICAgICAgICAgICAgICBpID0gKGR5ICsgeCkgKiBieXRlczsgLy8gcG9pbnQgaW5kZXggaW4gdGhlIGltYWdlIGRhdGFcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtkeSArIHhdID09PSAxKSBjb250aW51ZTsgLy8gY2hlY2sgd2hldGhlciB0aGUgcG9pbnQgaGFzIGJlZW4gdmlzaXRlZFxyXG5cclxuICAgICAgICAgICAgICAgIGNoZWNrWSA9IHRydWU7IC8vIGlmIHRoZSBjb2xvciBvZiB0aGUgbmV3IHBvaW50KHgseSkgaXMgc2ltaWxhciB0byB0aGUgc2FtcGxlIGNvbG9yIG5lZWQgdG8gY2hlY2sgbWlubWF4IGZvciBZIFxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdFtkeSArIHhdID0gMTsgLy8gbWFyayBhIG5ldyBwb2ludCBpbiBtYXNrXHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2R5ICsgeF0gPSAxOyAvLyBtYXJrIGEgbmV3IHBvaW50IGFzIHZpc2l0ZWRcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpXSAtIHNhbXBsZUNvbG9yWzBdOyAvLyBjaGVjayBieSByZWRcclxuICAgICAgICAgICAgICAgIGlmIChjID4gY29sb3JUaHJlc2hvbGQgfHwgYyA8IC1jb2xvclRocmVzaG9sZCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgIGlmIChjID4gY29sb3JUaHJlc2hvbGQgfHwgYyA8IC1jb2xvclRocmVzaG9sZCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMl0gLSBzYW1wbGVDb2xvclsyXTsgLy8gY2hlY2sgYnkgYmx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB4bCA9IHggLSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0byBsZWZ0IHNpZGUgc3RhcnRpbmcgd2l0aCB0aGUgbGVmdCBuZWlnaGJvclxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHhsID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkeWwgPSBkeSArIHhsO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBkeWwgKiBieXRlczsgLy8gcG9pbnQgaW5kZXggaW4gdGhlIGltYWdlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtkeWxdID09PSAxKSBicmVhazsgLy8gY2hlY2sgd2hldGhlciB0aGUgcG9pbnQgaGFzIGJlZW4gdmlzaXRlZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZHlsXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtkeWxdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB4bC0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGRhdGFbaV0gLSBzYW1wbGVDb2xvclswXTsgLy8gY2hlY2sgYnkgcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGNvbG9yVGhyZXNob2xkIHx8IGMgPCAtY29sb3JUaHJlc2hvbGQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBkYXRhW2kgKyAyXSAtIHNhbXBsZUNvbG9yWzJdOyAvLyBjaGVjayBieSBibHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHhyID0geCArIDE7XHJcbiAgICAgICAgICAgICAgICAvLyB3YWxrIHRvIHJpZ2h0IHNpZGUgc3RhcnRpbmcgd2l0aCB0aGUgcmlnaHQgbmVpZ2hib3JcclxuICAgICAgICAgICAgICAgIHdoaWxlICh4ciA8IHcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkeXIgPSBkeSArIHhyO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBkeXIgKiBieXRlczsgLy8gaW5kZXggcG9pbnQgaW4gdGhlIGltYWdlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtkeXJdID09PSAxKSBicmVhazsgLy8gY2hlY2sgd2hldGhlciB0aGUgcG9pbnQgaGFzIGJlZW4gdmlzaXRlZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZHlyXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtkeXJdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB4cisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2xvciBvZiB0aGUgc2FtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGRhdGFbaV0gLSBzYW1wbGVDb2xvclswXTsgLy8gY2hlY2sgYnkgcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjID0gZGF0YVtpICsgMV0gLSBzYW1wbGVDb2xvclsxXTsgLy8gY2hlY2sgYnkgZ3JlZW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGNvbG9yVGhyZXNob2xkIHx8IGMgPCAtY29sb3JUaHJlc2hvbGQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBkYXRhW2kgKyAyXSAtIHNhbXBsZUNvbG9yWzJdOyAvLyBjaGVjayBieSBibHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBjb2xvclRocmVzaG9sZCB8fCBjIDwgLWNvbG9yVGhyZXNob2xkKSBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBtaW5tYXggZm9yIFhcclxuICAgICAgICAgICAgICAgIGlmICh4bCA8IG1pblgpIG1pblggPSB4bCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeHIgPiBtYXhYKSBtYXhYID0geHIgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld1kgPSBlbC55IC0gZWwuZGlyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1kgPj0gMCAmJiBuZXdZIDwgaCkgeyAvLyBhZGQgdHdvIHNjYW5uaW5nIGxpbmVzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gKHkgLSBkaXIpIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bCA8IGVsLmxlZnQpIHN0YWNrLnB1c2goeyB5OiBuZXdZLCBsZWZ0OiB4bCwgcmlnaHQ6IGVsLmxlZnQsIGRpcjogLWVsLmRpciB9KTsgLy8gZnJvbSBcIm5ldyBsZWZ0XCIgdG8gXCJjdXJyZW50IGxlZnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5yaWdodCA8IHhyKSBzdGFjay5wdXNoKHsgeTogbmV3WSwgbGVmdDogZWwucmlnaHQsIHJpZ2h0OiB4ciwgZGlyOiAtZWwuZGlyIH0pOyAvLyBmcm9tIFwiY3VycmVudCByaWdodFwiIHRvIFwibmV3IHJpZ2h0XCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld1kgPSBlbC55ICsgZWwuZGlyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1kgPj0gMCAmJiBuZXdZIDwgaCkgeyAvLyBhZGQgdGhlIHNjYW5uaW5nIGxpbmUgaW4gdGhlIGRpcmVjdGlvbiAoeSArIGRpcikgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhsIDwgeHIpIHN0YWNrLnB1c2goeyB5OiBuZXdZLCBsZWZ0OiB4bCwgcmlnaHQ6IHhyLCBkaXI6IGVsLmRpciB9KTsgLy8gZnJvbSBcIm5ldyBsZWZ0XCIgdG8gXCJuZXcgcmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG1pbm1heCBmb3IgWSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgaWYgKGNoZWNrWSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnkgPCBtaW5ZKSBtaW5ZID0gZWwueTtcclxuICAgICAgICAgICAgICAgIGlmIChlbC55ID4gbWF4WSkgbWF4WSA9IGVsLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChzdGFjay5sZW5ndGggPiAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogcmVzdWx0LFxyXG4gICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIG1pblg6IG1pblgsXHJcbiAgICAgICAgICAgICAgICBtaW5ZOiBtaW5ZLFxyXG4gICAgICAgICAgICAgICAgbWF4WDogbWF4WCxcclxuICAgICAgICAgICAgICAgIG1heFk6IG1heFlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKiogQXBwbHkgdGhlIGdhdXNzLWJsdXIgZmlsdGVyIHRvIGJpbmFyeSBtYXNrXHJcbiAgICAgICogQWxnb3JpdGhtczogaHR0cDovL2Jsb2cuaXZhbmsubmV0L2Zhc3Rlc3QtZ2F1c3NpYW4tYmx1ci5odG1sXHJcbiAgICAgICogaHR0cDovL3d3dy5saWJyb3cuY29tL2FydGljbGVzL2FydGljbGUtOVxyXG4gICAgICAqIGh0dHA6Ly9lbHlueHNkay5mcmVlLmZyL2V4dC1kb2NzL0JsdXIvRmFzdF9ib3hfYmx1ci5wZGZcclxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFzazoge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHQsIHtPYmplY3R9IGJvdW5kc1xyXG4gICAgICAqIEBwYXJhbSB7aW50fSBibHVyIHJhZGl1c1xyXG4gICAgICAqIEByZXR1cm4ge09iamVjdH0gbWFzazoge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHQsIHtPYmplY3R9IGJvdW5kc1xyXG4gICAgICAqL1xyXG4gICAgbGliLmdhdXNzQmx1ciA9IGZ1bmN0aW9uKG1hc2ssIHJhZGl1cykge1xyXG5cclxuICAgICAgICB2YXIgaSwgaywgazEsIHgsIHksIHZhbCwgc3RhcnQsIGVuZCxcclxuICAgICAgICAgICAgbiA9IHJhZGl1cyAqIDIgKyAxLCAvLyBzaXplIG9mIHRoZSBwYXR0ZXJuIGZvciByYWRpdXMtbmVpZ2hib3JzIChmcm9tIC1yIHRvICtyIHdpdGggdGhlIGNlbnRlciBwb2ludClcclxuICAgICAgICAgICAgczIgPSByYWRpdXMgKiByYWRpdXMsXHJcbiAgICAgICAgICAgIHdnID0gbmV3IEZsb2F0MzJBcnJheShuKSwgLy8gd2VpZ2h0c1xyXG4gICAgICAgICAgICB0b3RhbCA9IDAsIC8vIHN1bSBvZiB3ZWlnaHRzKHVzZWQgZm9yIG5vcm1hbGl6YXRpb24pXHJcbiAgICAgICAgICAgIHcgPSBtYXNrLndpZHRoLFxyXG4gICAgICAgICAgICBoID0gbWFzay5oZWlnaHQsXHJcbiAgICAgICAgICAgIGRhdGEgPSBtYXNrLmRhdGEsXHJcbiAgICAgICAgICAgIG1pblggPSBtYXNrLmJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICBtYXhYID0gbWFzay5ib3VuZHMubWF4WCxcclxuICAgICAgICAgICAgbWluWSA9IG1hc2suYm91bmRzLm1pblksXHJcbiAgICAgICAgICAgIG1heFkgPSBtYXNrLmJvdW5kcy5tYXhZO1xyXG5cclxuICAgICAgICAvLyBjYWxjIGdhdXNzIHdlaWdodHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFkaXVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRzcSA9IChyYWRpdXMgLSBpKSAqIChyYWRpdXMgLSBpKTtcclxuICAgICAgICAgICAgdmFyIHd3ID0gTWF0aC5leHAoLWRzcSAvICgyLjAgKiBzMikpIC8gKDIgKiBNYXRoLlBJICogczIpO1xyXG4gICAgICAgICAgICB3Z1tyYWRpdXMgKyBpXSA9IHdnW3JhZGl1cyAtIGldID0gd3c7XHJcbiAgICAgICAgICAgIHRvdGFsICs9IDIgKiB3dztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB3ZWlnaHRzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICB3Z1tpXSAvPSB0b3RhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSh3ICogaCksIC8vIHJlc3VsdCBtYXNrXHJcbiAgICAgICAgICAgIGVuZFggPSByYWRpdXMgKyB3LFxyXG4gICAgICAgICAgICBlbmRZID0gcmFkaXVzICsgaDtcclxuXHJcbiAgICAgICAgLy93YWxrIHRocm91Z2ggYWxsIHNvdXJjZSBwb2ludHMgZm9yIGJsdXJcclxuICAgICAgICBmb3IgKHkgPSBtaW5ZOyB5IDwgbWF4WSArIDE7IHkrKylcclxuICAgICAgICAgICAgZm9yICh4ID0gbWluWDsgeCA8IG1heFggKyAxOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0geSAqIHcgKyB4OyAvLyBpbmRleCBvZiB0aGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcmFkaXVzIC0geCA+IDAgPyByYWRpdXMgLSB4IDogMDtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGVuZFggLSB4IDwgbiA/IGVuZFggLSB4IDogbjsgLy8gTWF0aC5taW4oKCgodyAtIDEpIC0geCkgKyByYWRpdXMpICsgMSwgbik7XHJcbiAgICAgICAgICAgICAgICBrMSA9IGsgLSByYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAvLyB3YWxrIHRocm91Z2ggeC1uZWlnaGJvcnNcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gZGF0YVtrMSArIGldICogd2dbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJhZGl1cyAtIHkgPiAwID8gcmFkaXVzIC0geSA6IDA7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBlbmRZIC0geSA8IG4gPyBlbmRZIC0geSA6IG47IC8vIE1hdGgubWluKCgoKGggLSAxKSAtIHkpICsgcmFkaXVzKSArIDEsIG4pO1xyXG4gICAgICAgICAgICAgICAgazEgPSBrIC0gcmFkaXVzICogdztcclxuICAgICAgICAgICAgICAgIC8vIHdhbGsgdGhyb3VnaCB5LW5laWdoYm9yc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBkYXRhW2sxICsgaSAqIHddICogd2dbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRba10gPSB2YWwgPiAwLjUgPyAxIDogMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiByZXN1bHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGgsXHJcbiAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgbWluWDogbWluWCxcclxuICAgICAgICAgICAgICAgIG1pblk6IG1pblksXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBtYXhYLFxyXG4gICAgICAgICAgICAgICAgbWF4WTogbWF4WVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIGJvcmRlciBpbmRleCBhcnJheSBvZiBib3VuZGFyeSBwb2ludHMgb2YgdGhlIG1hc2sgd2l0aCByYWRpdXMtbmVpZ2hib3JzXHJcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG1hc2s6IHtVaW50OEFycmF5fSBkYXRhLCB7aW50fSB3aWR0aCwge2ludH0gaGVpZ2h0LCB7T2JqZWN0fSBib3VuZHNcclxuICAgICAgKiBAcGFyYW0ge2ludH0gYmx1ciByYWRpdXNcclxuICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHZpc2l0ZWQ6IG1hc2sgb2YgdmlzaXRlZCBwb2ludHMgKG9wdGlvbmFsKSBcclxuICAgICAgKiBAcmV0dXJuIHtBcnJheX0gYm9yZGVyIGluZGV4IGFycmF5IG9mIGJvdW5kYXJ5IHBvaW50cyB3aXRoIHJhZGl1cy1uZWlnaGJvcnMgKG9ubHkgcG9pbnRzIG5lZWQgZm9yIGJsdXIpXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVCb3JkZXJGb3JCbHVyKG1hc2ssIHJhZGl1cywgdmlzaXRlZCkge1xyXG5cclxuICAgICAgICB2YXIgeCwgaSwgaiwgeSwgaywgazEsIGsyLFxyXG4gICAgICAgICAgICB3ID0gbWFzay53aWR0aCxcclxuICAgICAgICAgICAgaCA9IG1hc2suaGVpZ2h0LFxyXG4gICAgICAgICAgICBkYXRhID0gbWFzay5kYXRhLFxyXG4gICAgICAgICAgICB2aXNpdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5YID0gbWFzay5ib3VuZHMubWluWCxcclxuICAgICAgICAgICAgbWF4WCA9IG1hc2suYm91bmRzLm1heFgsXHJcbiAgICAgICAgICAgIG1pblkgPSBtYXNrLmJvdW5kcy5taW5ZLFxyXG4gICAgICAgICAgICBtYXhZID0gbWFzay5ib3VuZHMubWF4WSxcclxuICAgICAgICAgICAgbGVuID0gdyAqIGgsXHJcbiAgICAgICAgICAgIHRlbXAgPSBuZXcgVWludDhBcnJheShsZW4pLCAvLyBhdXhpbGlhcnkgYXJyYXkgdG8gY2hlY2sgdW5pcXVlbmVzc1xyXG4gICAgICAgICAgICBib3JkZXIgPSBbXSwgLy8gb25seSBib3JkZXIgcG9pbnRzXHJcbiAgICAgICAgICAgIHgwID0gTWF0aC5tYXgobWluWCwgMSksXHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4obWF4WCwgdyAtIDIpLFxyXG4gICAgICAgICAgICB5MCA9IE1hdGgubWF4KG1pblksIDEpLFxyXG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKG1heFksIGggLSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHZpc2l0ZWQgJiYgdmlzaXRlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdmlzaXRlZCBwb2ludHMgKG9ubHkgXCJibGFja1wiKVxyXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2tdID09PSAxKSB2aXNpdGVkRGF0YVtrXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdhbGsgdGhyb3VnaCBpbm5lciB2YWx1ZXMgZXhjZXB0IHBvaW50cyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGltYWdlXHJcbiAgICAgICAgZm9yICh5ID0geTA7IHkgPCB5MSArIDE7IHkrKylcclxuICAgICAgICAgICAgZm9yICh4ID0geDA7IHggPCB4MSArIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgayA9IHkgKiB3ICsgeDtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2tdID09PSAwKSBjb250aW51ZTsgLy8gXCJ3aGl0ZVwiIHBvaW50IGlzbid0IHRoZSBib3JkZXJcclxuICAgICAgICAgICAgICAgIGsxID0gayArIHc7IC8vIHkgKyAxXHJcbiAgICAgICAgICAgICAgICBrMiA9IGsgLSB3OyAvLyB5IC0gMVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYW55IG5laWdoYm9yIHdpdGggYSBcIndoaXRlXCIgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkRGF0YVtrICsgMV0gPT09IDAgfHwgdmlzaXRlZERhdGFbayAtIDFdID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZERhdGFbazFdID09PSAwIHx8IHZpc2l0ZWREYXRhW2sxICsgMV0gPT09IDAgfHwgdmlzaXRlZERhdGFbazEgLSAxXSA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWREYXRhW2syXSA9PT0gMCB8fCB2aXNpdGVkRGF0YVtrMiArIDFdID09PSAwIHx8IHZpc2l0ZWREYXRhW2syIC0gMV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmICh2aXNpdGVkRGF0YVtrICsgMV0gKyB2aXNpdGVkRGF0YVtrIC0gMV0gKyBcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICB2aXNpdGVkRGF0YVtrMV0gKyB2aXNpdGVkRGF0YVtrMSArIDFdICsgdmlzaXRlZERhdGFbazEgLSAxXSArXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgdmlzaXRlZERhdGFbazJdICsgdmlzaXRlZERhdGFbazIgKyAxXSArIHZpc2l0ZWREYXRhW2syIC0gMV0gPT0gOCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLnB1c2goayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2FsayB0aHJvdWdoIHBvaW50cyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGltYWdlIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIC8vIGlmIHRoZSBcImJsYWNrXCIgcG9pbnQgaXMgYWRqYWNlbnQgdG8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBpbWFnZSwgaXQgaXMgYSBib3JkZXIgcG9pbnRcclxuICAgICAgICBpZiAobWluWCA9PSAwKVxyXG4gICAgICAgICAgICBmb3IgKHkgPSBtaW5ZOyB5IDwgbWF4WSArIDE7IHkrKylcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW3kgKiB3XSA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIucHVzaCh5ICogdyk7XHJcblxyXG4gICAgICAgIGlmIChtYXhYID09IHcgLSAxKVxyXG4gICAgICAgICAgICBmb3IgKHkgPSBtaW5ZOyB5IDwgbWF4WSArIDE7IHkrKylcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW3kgKiB3ICsgbWF4WF0gPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLnB1c2goeSAqIHcgKyBtYXhYKTtcclxuXHJcbiAgICAgICAgaWYgKG1pblkgPT0gMClcclxuICAgICAgICAgICAgZm9yICh4ID0gbWluWDsgeCA8IG1heFggKyAxOyB4KyspXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVt4XSA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIucHVzaCh4KTtcclxuXHJcbiAgICAgICAgaWYgKG1heFkgPT0gaCAtIDEpXHJcbiAgICAgICAgICAgIGZvciAoeCA9IG1pblg7IHggPCBtYXhYICsgMTsgeCsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbbWF4WSAqIHcgKyB4XSA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIucHVzaChtYXhZICogdyArIHgpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIC8vIGJvcmRlciBwb2ludHMgd2l0aCByYWRpdXMtbmVpZ2hib3JzXHJcbiAgICAgICAgICAgIHN0YXJ0LCBlbmQsXHJcbiAgICAgICAgICAgIGVuZFggPSByYWRpdXMgKyB3LFxyXG4gICAgICAgICAgICBlbmRZID0gcmFkaXVzICsgaCxcclxuICAgICAgICAgICAgbiA9IHJhZGl1cyAqIDIgKyAxOyAvLyBzaXplIG9mIHRoZSBwYXR0ZXJuIGZvciByYWRpdXMtbmVpZ2hib3JzIChmcm9tIC1yIHRvICtyIHdpdGggdGhlIGNlbnRlciBwb2ludClcclxuXHJcbiAgICAgICAgbGVuID0gYm9yZGVyLmxlbmd0aDtcclxuICAgICAgICAvLyB3YWxrIHRocm91Z2ggcmFkaXVzLW5laWdoYm9ycyBvZiBib3JkZXIgcG9pbnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgcmVzdWx0IGFycmF5XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgIGsgPSBib3JkZXJbal07IC8vIGluZGV4IG9mIHRoZSBib3JkZXIgcG9pbnRcclxuICAgICAgICAgICAgdGVtcFtrXSA9IDE7IC8vIG1hcmsgYm9yZGVyIHBvaW50XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGspOyAvLyBzYXZlIHRoZSBib3JkZXIgcG9pbnRcclxuICAgICAgICAgICAgeCA9IGsgJSB3OyAvLyBjYWxjIHggYnkgaW5kZXhcclxuICAgICAgICAgICAgeSA9IChrIC0geCkgLyB3OyAvLyBjYWxjIHkgYnkgaW5kZXhcclxuICAgICAgICAgICAgc3RhcnQgPSByYWRpdXMgLSB4ID4gMCA/IHJhZGl1cyAtIHggOiAwO1xyXG4gICAgICAgICAgICBlbmQgPSBlbmRYIC0geCA8IG4gPyBlbmRYIC0geCA6IG47IC8vIE1hdGgubWluKCgoKHcgLSAxKSAtIHgpICsgcmFkaXVzKSArIDEsIG4pO1xyXG4gICAgICAgICAgICBrMSA9IGsgLSByYWRpdXM7XHJcbiAgICAgICAgICAgIC8vIHdhbGsgdGhyb3VnaCB4LW5laWdoYm9yc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBrMiA9IGsxICsgaTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wW2syXSA9PT0gMCkgeyAvLyBjaGVjayB0aGUgdW5pcXVlbmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBbazJdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnQgPSByYWRpdXMgLSB5ID4gMCA/IHJhZGl1cyAtIHkgOiAwO1xyXG4gICAgICAgICAgICBlbmQgPSBlbmRZIC0geSA8IG4gPyBlbmRZIC0geSA6IG47IC8vIE1hdGgubWluKCgoKGggLSAxKSAtIHkpICsgcmFkaXVzKSArIDEsIG4pO1xyXG4gICAgICAgICAgICBrMSA9IGsgLSByYWRpdXMgKiB3O1xyXG4gICAgICAgICAgICAvLyB3YWxrIHRocm91Z2ggeS1uZWlnaGJvcnNcclxuICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgazIgPSBrMSArIGkgKiB3O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBbazJdID09PSAwKSB7IC8vIGNoZWNrIHRoZSB1bmlxdWVuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFtrMl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGsyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKiBBcHBseSB0aGUgZ2F1c3MtYmx1ciBmaWx0ZXIgT05MWSB0byBib3JkZXIgcG9pbnRzIHdpdGggcmFkaXVzLW5laWdoYm9yc1xyXG4gICAgICAqIEFsZ29yaXRobXM6IGh0dHA6Ly9ibG9nLml2YW5rLm5ldC9mYXN0ZXN0LWdhdXNzaWFuLWJsdXIuaHRtbFxyXG4gICAgICAqIGh0dHA6Ly93d3cubGlicm93LmNvbS9hcnRpY2xlcy9hcnRpY2xlLTlcclxuICAgICAgKiBodHRwOi8vZWx5bnhzZGsuZnJlZS5mci9leHQtZG9jcy9CbHVyL0Zhc3RfYm94X2JsdXIucGRmXHJcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG1hc2s6IHtVaW50OEFycmF5fSBkYXRhLCB7aW50fSB3aWR0aCwge2ludH0gaGVpZ2h0LCB7T2JqZWN0fSBib3VuZHNcclxuICAgICAgKiBAcGFyYW0ge2ludH0gYmx1ciByYWRpdXNcclxuICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHZpc2l0ZWQ6IG1hc2sgb2YgdmlzaXRlZCBwb2ludHMgKG9wdGlvbmFsKSBcclxuICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG1hc2s6IHtVaW50OEFycmF5fSBkYXRhLCB7aW50fSB3aWR0aCwge2ludH0gaGVpZ2h0LCB7T2JqZWN0fSBib3VuZHNcclxuICAgICAgKi9cclxuICAgIGxpYi5nYXVzc0JsdXJPbmx5Qm9yZGVyID0gZnVuY3Rpb24obWFzaywgcmFkaXVzLCB2aXNpdGVkKSB7XHJcblxyXG4gICAgICAgIHZhciBib3JkZXIgPSBjcmVhdGVCb3JkZXJGb3JCbHVyKG1hc2ssIHJhZGl1cywgdmlzaXRlZCksIC8vIGdldCBib3JkZXIgcG9pbnRzIHdpdGggcmFkaXVzLW5laWdoYm9yc1xyXG4gICAgICAgICAgICB3dywgZHNxLCBpLCBqLCBrLCBrMSwgeCwgeSwgdmFsLCBzdGFydCwgZW5kLFxyXG4gICAgICAgICAgICBuID0gcmFkaXVzICogMiArIDEsIC8vIHNpemUgb2YgdGhlIHBhdHRlcm4gZm9yIHJhZGl1cy1uZWlnaGJvcnMgKGZyb20gLXIgdG8gK3Igd2l0aCBjZW50ZXIgcG9pbnQpXHJcbiAgICAgICAgICAgIHMyID0gMiAqIHJhZGl1cyAqIHJhZGl1cyxcclxuICAgICAgICAgICAgd2cgPSBuZXcgRmxvYXQzMkFycmF5KG4pLCAvLyB3ZWlnaHRzXHJcbiAgICAgICAgICAgIHRvdGFsID0gMCwgLy8gc3VtIG9mIHdlaWdodHModXNlZCBmb3Igbm9ybWFsaXphdGlvbilcclxuICAgICAgICAgICAgdyA9IG1hc2sud2lkdGgsXHJcbiAgICAgICAgICAgIGggPSBtYXNrLmhlaWdodCxcclxuICAgICAgICAgICAgZGF0YSA9IG1hc2suZGF0YSxcclxuICAgICAgICAgICAgbWluWCA9IG1hc2suYm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgIG1heFggPSBtYXNrLmJvdW5kcy5tYXhYLFxyXG4gICAgICAgICAgICBtaW5ZID0gbWFzay5ib3VuZHMubWluWSxcclxuICAgICAgICAgICAgbWF4WSA9IG1hc2suYm91bmRzLm1heFksXHJcbiAgICAgICAgICAgIGxlbiA9IGJvcmRlci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIGNhbGMgZ2F1c3Mgd2VpZ2h0c1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXM7IGkrKykge1xyXG4gICAgICAgICAgICBkc3EgPSAocmFkaXVzIC0gaSkgKiAocmFkaXVzIC0gaSk7XHJcbiAgICAgICAgICAgIHd3ID0gTWF0aC5leHAoLWRzcSAvIHMyKSAvIE1hdGguUEk7XHJcbiAgICAgICAgICAgIHdnW3JhZGl1cyArIGldID0gd2dbcmFkaXVzIC0gaV0gPSB3dztcclxuICAgICAgICAgICAgdG90YWwgKz0gMiAqIHd3O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3JtYWxpemF0aW9uIHdlaWdodHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHdnW2ldIC89IHRvdGFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGEpLCAvLyBjb3B5IHRoZSBzb3VyY2UgbWFza1xyXG4gICAgICAgICAgICBlbmRYID0gcmFkaXVzICsgdyxcclxuICAgICAgICAgICAgZW5kWSA9IHJhZGl1cyArIGg7XHJcblxyXG4gICAgICAgIC8vd2FsayB0aHJvdWdoIGFsbCBib3JkZXIgcG9pbnRzIGZvciBibHVyXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGsgPSBib3JkZXJbaV07IC8vIGluZGV4IG9mIHRoZSBib3JkZXIgcG9pbnRcclxuICAgICAgICAgICAgdmFsID0gMDtcclxuICAgICAgICAgICAgeCA9IGsgJSB3OyAvLyBjYWxjIHggYnkgaW5kZXhcclxuICAgICAgICAgICAgeSA9IChrIC0geCkgLyB3OyAvLyBjYWxjIHkgYnkgaW5kZXhcclxuICAgICAgICAgICAgc3RhcnQgPSByYWRpdXMgLSB4ID4gMCA/IHJhZGl1cyAtIHggOiAwO1xyXG4gICAgICAgICAgICBlbmQgPSBlbmRYIC0geCA8IG4gPyBlbmRYIC0geCA6IG47IC8vIE1hdGgubWluKCgoKHcgLSAxKSAtIHgpICsgcmFkaXVzKSArIDEsIG4pO1xyXG4gICAgICAgICAgICBrMSA9IGsgLSByYWRpdXM7XHJcbiAgICAgICAgICAgIC8vIHdhbGsgdGhyb3VnaCB4LW5laWdoYm9yc1xyXG4gICAgICAgICAgICBmb3IgKGogPSBzdGFydDsgaiA8IGVuZDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgKz0gZGF0YVtrMSArIGpdICogd2dbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbCA+IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gMTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG1pbm1heFxyXG4gICAgICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFkaXVzIC0geSA+IDAgPyByYWRpdXMgLSB5IDogMDtcclxuICAgICAgICAgICAgZW5kID0gZW5kWSAtIHkgPCBuID8gZW5kWSAtIHkgOiBuOyAvLyBNYXRoLm1pbigoKChoIC0gMSkgLSB5KSArIHJhZGl1cykgKyAxLCBuKTtcclxuICAgICAgICAgICAgazEgPSBrIC0gcmFkaXVzICogdztcclxuICAgICAgICAgICAgLy8gd2FsayB0aHJvdWdoIHktbmVpZ2hib3JzXHJcbiAgICAgICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgZW5kOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBkYXRhW2sxICsgaiAqIHddICogd2dbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbCA+IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gMTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG1pbm1heFxyXG4gICAgICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdCxcclxuICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgIGhlaWdodDogaCxcclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICBtaW5YOiBtaW5YLFxyXG4gICAgICAgICAgICAgICAgbWluWTogbWluWSxcclxuICAgICAgICAgICAgICAgIG1heFg6IG1heFgsXHJcbiAgICAgICAgICAgICAgICBtYXhZOiBtYXhZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQ3JlYXRlIGEgYm9yZGVyIG1hc2sgKG9ubHkgYm91bmRhcnkgcG9pbnRzKVxyXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXNrOiB7VWludDhBcnJheX0gZGF0YSwge2ludH0gd2lkdGgsIHtpbnR9IGhlaWdodCwge09iamVjdH0gYm91bmRzXHJcbiAgICAgICogQHJldHVybiB7T2JqZWN0fSBib3JkZXIgbWFzazoge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHQsIHtPYmplY3R9IG9mZnNldFxyXG4gICAgICAqL1xyXG4gICAgbGliLmNyZWF0ZUJvcmRlck1hc2sgPSBmdW5jdGlvbihtYXNrKSB7XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCBrLCBrMSwgazIsXHJcbiAgICAgICAgICAgIHcgPSBtYXNrLndpZHRoLFxyXG4gICAgICAgICAgICBoID0gbWFzay5oZWlnaHQsXHJcbiAgICAgICAgICAgIGRhdGEgPSBtYXNrLmRhdGEsXHJcbiAgICAgICAgICAgIG1pblggPSBtYXNrLmJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICBtYXhYID0gbWFzay5ib3VuZHMubWF4WCxcclxuICAgICAgICAgICAgbWluWSA9IG1hc2suYm91bmRzLm1pblksXHJcbiAgICAgICAgICAgIG1heFkgPSBtYXNrLmJvdW5kcy5tYXhZLFxyXG4gICAgICAgICAgICBydyA9IG1heFggLSBtaW5YICsgMSwgLy8gYm91bmRzIHNpemVcclxuICAgICAgICAgICAgcmggPSBtYXhZIC0gbWluWSArIDEsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHJ3ICogcmgpLCAvLyByZWR1Y2VkIG1hc2sgKGJvdW5kcyBzaXplKVxyXG4gICAgICAgICAgICB4MCA9IE1hdGgubWF4KG1pblgsIDEpLFxyXG4gICAgICAgICAgICB4MSA9IE1hdGgubWluKG1heFgsIHcgLSAyKSxcclxuICAgICAgICAgICAgeTAgPSBNYXRoLm1heChtaW5ZLCAxKSxcclxuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbihtYXhZLCBoIC0gMik7XHJcblxyXG4gICAgICAgIC8vIHdhbGsgdGhyb3VnaCBpbm5lciB2YWx1ZXMgZXhjZXB0IHBvaW50cyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGltYWdlXHJcbiAgICAgICAgZm9yICh5ID0geTA7IHkgPCB5MSArIDE7IHkrKylcclxuICAgICAgICAgICAgZm9yICh4ID0geDA7IHggPCB4MSArIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgayA9IHkgKiB3ICsgeDtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2tdID09PSAwKSBjb250aW51ZTsgLy8gXCJ3aGl0ZVwiIHBvaW50IGlzbid0IHRoZSBib3JkZXJcclxuICAgICAgICAgICAgICAgIGsxID0gayArIHc7IC8vIHkgKyAxXHJcbiAgICAgICAgICAgICAgICBrMiA9IGsgLSB3OyAvLyB5IC0gMVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYW55IG5laWdoYm9yIHdpdGggYSBcIndoaXRlXCIgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2sgKyAxXSA9PT0gMCB8fCBkYXRhW2sgLSAxXSA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbazFdID09PSAwIHx8IGRhdGFbazEgKyAxXSA9PT0gMCB8fCBkYXRhW2sxIC0gMV0gPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2syXSA9PT0gMCB8fCBkYXRhW2syICsgMV0gPT09IDAgfHwgZGF0YVtrMiAtIDFdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoZGF0YVtrICsgMV0gKyBkYXRhW2sgLSAxXSArIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGRhdGFbazFdICsgZGF0YVtrMSArIDFdICsgZGF0YVtrMSAtIDFdICtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBkYXRhW2syXSArIGRhdGFbazIgKyAxXSArIGRhdGFbazIgLSAxXSA9PSA4KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbKHkgLSBtaW5ZKSAqIHJ3ICsgKHggLSBtaW5YKV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdhbGsgdGhyb3VnaCBwb2ludHMgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBpbWFnZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAvLyBpZiB0aGUgXCJibGFja1wiIHBvaW50IGlzIGFkamFjZW50IHRvIHRoZSBib3VuZGFyeSBvZiB0aGUgaW1hZ2UsIGl0IGlzIGEgYm9yZGVyIHBvaW50XHJcbiAgICAgICAgaWYgKG1pblggPT0gMClcclxuICAgICAgICAgICAgZm9yICh5ID0gbWluWTsgeSA8IG1heFkgKyAxOyB5KyspXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVt5ICogd10gPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Wyh5IC0gbWluWSkgKiByd10gPSAxO1xyXG5cclxuICAgICAgICBpZiAobWF4WCA9PSB3IC0gMSlcclxuICAgICAgICAgICAgZm9yICh5ID0gbWluWTsgeSA8IG1heFkgKyAxOyB5KyspXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVt5ICogdyArIG1heFhdID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsoeSAtIG1pblkpICogcncgKyAobWF4WCAtIG1pblgpXSA9IDE7XHJcblxyXG4gICAgICAgIGlmIChtaW5ZID09IDApXHJcbiAgICAgICAgICAgIGZvciAoeCA9IG1pblg7IHggPCBtYXhYICsgMTsgeCsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbeF0gPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3ggLSBtaW5YXSA9IDE7XHJcblxyXG4gICAgICAgIGlmIChtYXhZID09IGggLSAxKVxyXG4gICAgICAgICAgICBmb3IgKHggPSBtaW5YOyB4IDwgbWF4WCArIDE7IHgrKylcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW21heFkgKiB3ICsgeF0gPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WyhtYXhZIC0gbWluWSkgKiBydyArICh4IC0gbWluWCldID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogcmVzdWx0LFxyXG4gICAgICAgICAgICB3aWR0aDogcncsXHJcbiAgICAgICAgICAgIGhlaWdodDogcmgsXHJcbiAgICAgICAgICAgIG9mZnNldDogeyB4OiBtaW5YLCB5OiBtaW5ZIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqIENyZWF0ZSBhIGJvcmRlciBpbmRleCBhcnJheSBvZiBib3VuZGFyeSBwb2ludHMgb2YgdGhlIG1hc2tcclxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFzazoge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHRcclxuICAgICAgKiBAcmV0dXJuIHtBcnJheX0gYm9yZGVyIGluZGV4IGFycmF5IGJvdW5kYXJ5IHBvaW50cyBvZiB0aGUgbWFza1xyXG4gICAgICAqL1xyXG4gICAgbGliLmdldEJvcmRlckluZGljZXMgPSBmdW5jdGlvbihtYXNrKSB7XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCBrLCBrMSwgazIsXHJcbiAgICAgICAgICAgIHcgPSBtYXNrLndpZHRoLFxyXG4gICAgICAgICAgICBoID0gbWFzay5oZWlnaHQsXHJcbiAgICAgICAgICAgIGRhdGEgPSBtYXNrLmRhdGEsXHJcbiAgICAgICAgICAgIGJvcmRlciA9IFtdLCAvLyBvbmx5IGJvcmRlciBwb2ludHNcclxuICAgICAgICAgICAgeDEgPSB3IC0gMSxcclxuICAgICAgICAgICAgeTEgPSBoIC0gMTtcclxuXHJcbiAgICAgICAgLy8gd2FsayB0aHJvdWdoIGlubmVyIHZhbHVlcyBleGNlcHQgcG9pbnRzIG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgaW1hZ2VcclxuICAgICAgICBmb3IgKHkgPSAxOyB5IDwgeTE7IHkrKylcclxuICAgICAgICAgICAgZm9yICh4ID0gMTsgeCA8IHgxOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGsgPSB5ICogdyArIHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtrXSA9PT0gMCkgY29udGludWU7IC8vIFwid2hpdGVcIiBwb2ludCBpc24ndCB0aGUgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICBrMSA9IGsgKyB3OyAvLyB5ICsgMVxyXG4gICAgICAgICAgICAgICAgazIgPSBrIC0gdzsgLy8geSAtIDFcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFueSBuZWlnaGJvciB3aXRoIGEgXCJ3aGl0ZVwiIGNvbG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtrICsgMV0gPT09IDAgfHwgZGF0YVtrIC0gMV0gPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2sxXSA9PT0gMCB8fCBkYXRhW2sxICsgMV0gPT09IDAgfHwgZGF0YVtrMSAtIDFdID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrMl0gPT09IDAgfHwgZGF0YVtrMiArIDFdID09PSAwIHx8IGRhdGFbazIgLSAxXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGRhdGFbayArIDFdICsgZGF0YVtrIC0gMV0gKyBcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBkYXRhW2sxXSArIGRhdGFbazEgKyAxXSArIGRhdGFbazEgLSAxXSArXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgZGF0YVtrMl0gKyBkYXRhW2syICsgMV0gKyBkYXRhW2syIC0gMV0gPT0gOCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLnB1c2goayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2FsayB0aHJvdWdoIHBvaW50cyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGltYWdlIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIC8vIGlmIHRoZSBcImJsYWNrXCIgcG9pbnQgaXMgYWRqYWNlbnQgdG8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBpbWFnZSwgaXQgaXMgYSBib3JkZXIgcG9pbnRcclxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaDsgeSsrKVxyXG4gICAgICAgICAgICBpZiAoZGF0YVt5ICogd10gPT09IDEpXHJcbiAgICAgICAgICAgICAgICBib3JkZXIucHVzaCh5ICogdyk7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IDA7IHggPCB3OyB4KyspXHJcbiAgICAgICAgICAgIGlmIChkYXRhW3hdID09PSAxKVxyXG4gICAgICAgICAgICAgICAgYm9yZGVyLnB1c2goeCk7XHJcblxyXG4gICAgICAgIGsgPSB3IC0gMTtcclxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaDsgeSsrKVxyXG4gICAgICAgICAgICBpZiAoZGF0YVt5ICogdyArIGtdID09PSAxKVxyXG4gICAgICAgICAgICAgICAgYm9yZGVyLnB1c2goeSAqIHcgKyBrKTtcclxuXHJcbiAgICAgICAgayA9IChoIC0gMSkgKiB3O1xyXG4gICAgICAgIGZvciAoeCA9IDA7IHggPCB3OyB4KyspXHJcbiAgICAgICAgICAgIGlmIChkYXRhW2sgKyB4XSA9PT0gMSlcclxuICAgICAgICAgICAgICAgIGJvcmRlci5wdXNoKGsgKyB4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvcmRlcjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKiBDcmVhdGUgYSBjb21wcmVzc2VkIG1hc2sgd2l0aCBhIFwid2hpdGVcIiBib3JkZXIgKDFweCBib3JkZXIgd2l0aCB6ZXJvIHZhbHVlcykgZm9yIHRoZSBjb250b3VyIHRyYWNpbmdcclxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFzazoge1VpbnQ4QXJyYXl9IGRhdGEsIHtpbnR9IHdpZHRoLCB7aW50fSBoZWlnaHQsIHtPYmplY3R9IGJvdW5kc1xyXG4gICAgICAqIEByZXR1cm4ge09iamVjdH0gYm9yZGVyIG1hc2s6IHtVaW50OEFycmF5fSBkYXRhLCB7aW50fSB3aWR0aCwge2ludH0gaGVpZ2h0LCB7T2JqZWN0fSBvZmZzZXRcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByZXBhcmVNYXNrKG1hc2spIHtcclxuICAgICAgICB2YXIgeCwgeSxcclxuICAgICAgICAgICAgdyA9IG1hc2sud2lkdGgsXHJcbiAgICAgICAgICAgIGRhdGEgPSBtYXNrLmRhdGEsXHJcbiAgICAgICAgICAgIG1pblggPSBtYXNrLmJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICBtYXhYID0gbWFzay5ib3VuZHMubWF4WCxcclxuICAgICAgICAgICAgbWluWSA9IG1hc2suYm91bmRzLm1pblksXHJcbiAgICAgICAgICAgIG1heFkgPSBtYXNrLmJvdW5kcy5tYXhZLFxyXG4gICAgICAgICAgICBydyA9IG1heFggLSBtaW5YICsgMywgLy8gYm91bmRzIHNpemUgKzEgcHggb24gZWFjaCBzaWRlIChhIFwid2hpdGVcIiBib3JkZXIpXHJcbiAgICAgICAgICAgIHJoID0gbWF4WSAtIG1pblkgKyAzLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShydyAqIHJoKTsgLy8gcmVkdWNlZCBtYXNrIChib3VuZHMgc2l6ZSlcclxuXHJcbiAgICAgICAgLy8gd2FsayB0aHJvdWdoIGlubmVyIHZhbHVlcyBhbmQgY29weSBvbmx5IFwiYmxhY2tcIiBwb2ludHMgdG8gdGhlIHJlc3VsdCBtYXNrXHJcbiAgICAgICAgZm9yICh5ID0gbWluWTsgeSA8IG1heFkgKyAxOyB5KyspXHJcbiAgICAgICAgICAgIGZvciAoeCA9IG1pblg7IHggPCBtYXhYICsgMTsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVt5ICogdyArIHhdID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsoeSAtIG1pblkgKyAxKSAqIHJ3ICsgKHggLSBtaW5YICsgMSldID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiByZXN1bHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiBydyxcclxuICAgICAgICAgICAgaGVpZ2h0OiByaCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB7IHg6IG1pblggLSAxLCB5OiBtaW5ZIC0gMSB9XHJcbiAgICAgICAgfTtcclxuICAgIH0gICAgICAgIFxyXG4gICAgLyoqIENyZWF0ZSBhIGNvbnRvdXIgYXJyYXkgZm9yIHRoZSBiaW5hcnkgbWFza1xyXG4gICAgICAqIEFsZ29yaXRobTogaHR0cDovL3d3dy5zY2llbmNlZGlyZWN0LmNvbS9zY2llbmNlL2FydGljbGUvcGlpL1MxMDc3MzE0MjAzMDAxNDAxXHJcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG1hc2s6IHtVaW50OEFycmF5fSBkYXRhLCB7aW50fSB3aWR0aCwge2ludH0gaGVpZ2h0LCB7T2JqZWN0fSBib3VuZHNcclxuICAgICAgKiBAcmV0dXJuIHtBcnJheX0gY29udG91cnM6IHtBcnJheX0gcG9pbnRzLCB7Ym9vbH0gaW5uZXIsIHtpbnR9IGxhYmVsXHJcbiAgICAgICovXHJcbiAgICBsaWIudHJhY2VDb250b3VycyA9IGZ1bmN0aW9uKG1hc2spIHtcclxuICAgICAgICB2YXIgbSA9IHByZXBhcmVNYXNrKG1hc2spLFxyXG4gICAgICAgICAgICBjb250b3VycyA9IFtdLFxyXG4gICAgICAgICAgICBsYWJlbCA9IDAsXHJcbiAgICAgICAgICAgIHcgPSBtLndpZHRoLFxyXG4gICAgICAgICAgICB3MiA9IHcgKiAyLFxyXG4gICAgICAgICAgICBoID0gbS5oZWlnaHQsXHJcbiAgICAgICAgICAgIHNyYyA9IG0uZGF0YSxcclxuICAgICAgICAgICAgZHggPSBtLm9mZnNldC54LFxyXG4gICAgICAgICAgICBkeSA9IG0ub2Zmc2V0LnksXHJcbiAgICAgICAgICAgIGRlc3QgPSBuZXcgVWludDhBcnJheShzcmMpLCAvLyBsYWJlbCBtYXRyaXhcclxuICAgICAgICAgICAgaSwgaiwgeCwgeSwgaywgazEsIGMsIGlubmVyLCBkaXIsIGZpcnN0LCBzZWNvbmQsIGN1cnJlbnQsIHByZXZpb3VzLCBuZXh0LCBkO1xyXG5cclxuICAgICAgICAvLyBhbGwgW2R4LGR5XSBwYWlycyAoYXJyYXkgaW5kZXggaXMgdGhlIGRpcmVjdGlvbilcclxuICAgICAgICAvLyA1IDYgN1xyXG4gICAgICAgIC8vIDQgWCAwXHJcbiAgICAgICAgLy8gMyAyIDFcclxuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IFtbMSwgMF0sIFsxLCAxXSwgWzAsIDFdLCBbLTEsIDFdLCBbLTEsIDBdLCBbLTEsIC0xXSwgWzAsIC0xXSwgWzEsIC0xXV07XHJcblxyXG4gICAgICAgIGZvciAoeSA9IDE7IHkgPCBoIC0gMTsgeSsrKVxyXG4gICAgICAgICAgICBmb3IgKHggPSAxOyB4IDwgdyAtIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgayA9IHkgKiB3ICsgeDtcclxuICAgICAgICAgICAgICAgIGlmIChzcmNba10gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAtdzsgaSA8IHcyOyBpICs9IHcyKSB7IC8vIGsgLSB3OiBvdXRlciB0cmFjaW5nICh5IC0gMSksIGsgKyB3OiBpbm5lciB0cmFjaW5nICh5ICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1trICsgaV0gPT09IDAgJiYgZGVzdFtrICsgaV0gPT09IDApIHsgLy8gbmVlZCBjb250b3VyIHRyYWNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyID0gaSA9PT0gdzsgLy8gaXMgaW5uZXIgY29udG91ciB0cmFjaW5nID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsKys7IC8vIGxhYmVsIGZvciB0aGUgbmV4dCBjb250b3VyXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gaW5uZXIgPyAyIDogNjsgLy8gc3RhcnQgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcHJldmlvdXMgPSBmaXJzdCA9IHsgeDogeCwgeTogeSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtjdXJyZW50LnkgKiB3ICsgY3VycmVudC54XSA9IGxhYmVsOyAvLyBtYXJrIGxhYmVsIGZvciB0aGUgY3VycmVudCBwb2ludCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieXBhc3MgYWxsIHRoZSBuZWlnaGJvcnMgYXJvdW5kIHRoZSBjdXJyZW50IHBvaW50IGluIGEgY2xvY2t3aXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSAoZGlyICsgMSkgJSA4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBuZXh0IHBvaW50IGJ5IG5ldyBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGRpcmVjdGlvbnNbZGlyXTsgLy8gaW5kZXggYXMgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB7IHg6IGN1cnJlbnQueCArIGRbMF0sIHk6IGN1cnJlbnQueSArIGRbMV0gfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsxID0gbmV4dC55ICogdyArIG5leHQueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1trMV0gPT09IDEpIC8vIGJsYWNrIGJvdW5kYXJ5IHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbazFdID0gbGFiZWw7IC8vIG1hcmsgYSBsYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtrMV0gPSAtMTsgLy8gbWFyayBhIHdoaXRlIGJvdW5kYXJ5IHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkgYnJlYWs7IC8vIG5vIG5laWdoYm91cnMgKG9uZS1wb2ludCBjb250b3VyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzLnggPT09IGZpcnN0LnggJiYgcHJldmlvdXMueSA9PT0gZmlyc3QueSAmJiBjdXJyZW50LnggPT09IHNlY29uZC54ICYmIGN1cnJlbnQueSA9PT0gc2Vjb25kLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBjcmVhdGluZyB0aGUgY29udG91ciBjb21wbGV0ZWQgd2hlbiByZXR1cm5lZCB0byBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHsgeDogcHJldmlvdXMueCArIGR4LCB5OiBwcmV2aW91cy55ICsgZHkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IChkaXIgKyA0KSAlIDg7IC8vIG5leHQgZGlyIChzeW1tZXRyaWNhbGx5IHRvIHRoZSBjdXJyZW50IGRpcmVjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHsgeDogZmlyc3QueCArIGR4LCB5OiBmaXJzdC55ICsgZHkgfSk7IC8vIGNsb3NlIHRoZSBjb250b3VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udG91cnMucHVzaCh7IGlubmVyOiBpbm5lciwgbGFiZWw6IGxhYmVsLCBwb2ludHM6IGMgfSk7IC8vIGFkZCBjb250b3VyIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRvdXJzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqIFNpbXBsaWZ5IGNvbnRvdXJzXHJcbiAgICAgICogQWxnb3JpdGhtczogaHR0cDovL3BzaW1wbC5zb3VyY2Vmb3JnZS5uZXQvZG91Z2xhcy1wZXVja2VyLmh0bWwgXHJcbiAgICAgICogaHR0cDovL25lZXJjLmlmbW8ucnUvd2lraS9pbmRleC5waHA/dGl0bGU9JUQwJUEzJUQwJUJGJUQxJTgwJUQwJUJFJUQxJTg5JUQwJUI1JUQwJUJEJUQwJUI4JUQwJUI1XyVEMCVCRiVEMCVCRSVEMCVCQiVEMCVCOCVEMCVCMyVEMCVCRSVEMCVCRCVEMCVCMCVEMCVCQiVEMSU4QyVEMCVCRCVEMCVCRSVEMCVCOV8lRDElODYlRDAlQjUlRDAlQkYlRDAlQjhcclxuICAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250b3Vyczoge0FycmF5fSBwb2ludHMsIHtib29sfSBpbm5lciwge2ludH0gbGFiZWxcclxuICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBzaW1wbGlmeSB0b2xlcmFudFxyXG4gICAgICAqIEBwYXJhbSB7aW50fSBzaW1wbGlmeSBjb3VudDogbWluIG51bWJlciBvZiBwb2ludHMgd2hlbiB0aGUgY29udG91ciBpcyBzaW1wbGlmaWVkXHJcbiAgICAgICogQHJldHVybiB7QXJyYXl9IGNvbnRvdXJzOiB7QXJyYXl9IHBvaW50cywge2Jvb2x9IGlubmVyLCB7aW50fSBsYWJlbCwge2ludH0gaW5pdGlhbENvdW50XHJcbiAgICAgICovXHJcbiAgICBsaWIuc2ltcGxpZnlDb250b3VycyA9IGZ1bmN0aW9uKGNvbnRvdXJzLCBzaW1wbGlmeVRvbGVyYW50LCBzaW1wbGlmeUNvdW50KSB7XHJcbiAgICAgICAgdmFyIGxlbkNvbnRvdXJzID0gY29udG91cnMubGVuZ3RoLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgaSwgaiwgaywgYywgcG9pbnRzLCBsZW4sIHJlc1BvaW50cywgbHN0LCBzdGFjaywgaWRzLFxyXG4gICAgICAgICAgICBtYXhkLCBtYXhpLCBkaXN0LCByMSwgcjIsIHIxMiwgZHgsIGR5LCBwaSwgcGYsIHBsO1xyXG5cclxuICAgICAgICAvLyB3YWxrIHRocm91Z2ggYWxsIGNvbnRvdXJzIFxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5Db250b3VyczsgaisrKSB7XHJcbiAgICAgICAgICAgIGMgPSBjb250b3Vyc1tqXTtcclxuICAgICAgICAgICAgcG9pbnRzID0gYy5wb2ludHM7XHJcbiAgICAgICAgICAgIGxlbiA9IGMucG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW4gPCBzaW1wbGlmeUNvdW50KSB7IC8vIGNvbnRvdXIgaXNuJ3Qgc2ltcGxpZmllZFxyXG4gICAgICAgICAgICAgICAgcmVzUG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNQb2ludHMucHVzaCh7IHg6IHBvaW50c1trXS54LCB5OiBwb2ludHNba10ueSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaW5uZXI6IGMuaW5uZXIsIGxhYmVsOiBjLmxhYmVsLCBwb2ludHM6IHJlc1BvaW50cywgaW5pdGlhbENvdW50OiBsZW4gfSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbHN0ID0gWzAsIGxlbiAtIDFdOyAvLyBhbHdheXMgYWRkIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xyXG4gICAgICAgICAgICBzdGFjayA9IFt7IGZpcnN0OiAwLCBsYXN0OiBsZW4gLSAxIH1dOyAvLyBmaXJzdCBwcm9jZXNzZWQgZWRnZVxyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaWRzID0gc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpZHMubGFzdCA8PSBpZHMuZmlyc3QgKyAxKSAvLyBubyBpbnRlcm1lZGlhdGUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWF4ZCA9IC0xLjA7IC8vIG1heCBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGN1cnJlbnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgbWF4aSA9IGlkcy5maXJzdDsgLy8gaW5kZXggb2YgbWF4aW1hbGx5IGRpc3RhbnQgcG9pbnRcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBpZHMuZmlyc3QgKyAxOyBpIDwgaWRzLmxhc3Q7IGkrKykgLy8gYnlwYXNzIGludGVybWVkaWF0ZSBwb2ludHMgaW4gZWRnZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGMgdGhlIGRpc3RhbmNlIGZyb20gY3VycmVudCBwb2ludCB0byBlZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgcGkgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcGYgPSBwb2ludHNbaWRzLmZpcnN0XTtcclxuICAgICAgICAgICAgICAgICAgICBwbCA9IHBvaW50c1tpZHMubGFzdF07XHJcbiAgICAgICAgICAgICAgICAgICAgZHggPSBwaS54IC0gcGYueDtcclxuICAgICAgICAgICAgICAgICAgICBkeSA9IHBpLnkgLSBwZi55O1xyXG4gICAgICAgICAgICAgICAgICAgIHIxID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICAgICAgICAgICAgICBkeCA9IHBpLnggLSBwbC54O1xyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gcGkueSAtIHBsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgcjIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gcGYueCAtIHBsLng7XHJcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBwZi55IC0gcGwueTtcclxuICAgICAgICAgICAgICAgICAgICByMTIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyMSA+PSBNYXRoLnNxcnQocjIgKiByMiArIHIxMiAqIHIxMikpIGRpc3QgPSByMjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyMiA+PSBNYXRoLnNxcnQocjEgKiByMSArIHIxMiAqIHIxMikpIGRpc3QgPSByMTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGRpc3QgPSBNYXRoLmFicygoZHkgKiBwaS54IC0gZHggKiBwaS55ICsgcGYueCAqIHBsLnkgLSBwbC54ICogcGYueSkgLyByMTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IG1heGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aSA9IGk7IC8vIHNhdmUgdGhlIGluZGV4IG9mIG1heGltYWxseSBkaXN0YW50IHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGQgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ZCA+IHNpbXBsaWZ5VG9sZXJhbnQpIC8vIGlmIHRoZSBtYXggXCJkZXZpYXRpb25cIiBpcyBsYXJnZXIgdGhhbiBhbGxvd2VkIHRoZW4uLi5cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsc3QucHVzaChtYXhpKTsgLy8gYWRkIGluZGV4IHRvIHRoZSBzaW1wbGlmaWVkIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsgZmlyc3Q6IGlkcy5maXJzdCwgbGFzdDogbWF4aSB9KTsgLy8gYWRkIHRoZSBsZWZ0IHBhcnQgZm9yIHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsgZmlyc3Q6IG1heGksIGxhc3Q6IGlkcy5sYXN0IH0pOyAvLyBhZGQgdGhlIHJpZ2h0IHBhcnQgZm9yIHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgICAgICAgcmVzUG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGxlbiA9IGxzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTsgLy8gcmVzdG9yZSBpbmRleCBvcmRlclxyXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc1BvaW50cy5wdXNoKHsgeDogcG9pbnRzW2xzdFtrXV0ueCwgeTogcG9pbnRzW2xzdFtrXV0ueSB9KTsgLy8gYWRkIHJlc3VsdCBwb2ludHMgdG8gdGhlIGNvcnJlY3Qgb3JkZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGlubmVyOiBjLmlubmVyLCBsYWJlbDogYy5sYWJlbCwgcG9pbnRzOiByZXNQb2ludHMsIGluaXRpYWxDb3VudDogYy5wb2ludHMubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGxpYjtcclxufSkoKTtcclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZSAhPT0gbnVsbCkgbW9kdWxlLmV4cG9ydHMgPSBNYWdpY1dhbmQ7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkgd2luZG93Lk1hZ2ljV2FuZCA9IE1hZ2ljV2FuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hZ2ljLXdhbmQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/magic-wand-tool/dist/magic-wand.js\n");

/***/ })

};
;